import serial
import time
import csv
import json
from datetime import datetime
from collections import deque

class AdvancedFSRController:
    def __init__(self, port='/dev/cu.usbmodem1101', baud_rate=9600):
        self.port = port
        self.baud_rate = baud_rate
        self.arduino = None
        self.is_connected = False
        self.is_monitoring = False
        
        self.fsr_history = deque(maxlen=1000)  
        self.session_data = list()
        
        self.stats = {
            'total_readings': 0,
            'max_pressure': 0,
            'min_pressure': 1023,
            'avg_pressure': 0,
            'session_start': None,
            'pressure_events': {
                'light_touches': 0,
                'light_squeezes': 0,
                'medium_squeezes': 0,
                'strong_squeezes': 0
            }
        }
        
    def connect(self):
        """Connect to Arduino"""
        try:
            self.arduino = serial.Serial(self.port, self.baud_rate)
            time.sleep(2)
            self.is_connected = True
            self.stats['session_start'] = datetime.now()
            print(f"Connected to Arduino on {self.port}")
            print(f"Session started at {self.stats['session_start'].strftime('%H:%M:%S')}")
            return True
        except serial.SerialException as e:
            print(f"Connection failed: {e}")
            return False
    
    def update_statistics(self, fsr_value, pressure_category):
        """Update running statistics"""
        self.stats['total_readings'] += 1
        self.stats['max_pressure'] = max(self.stats['max_pressure'], fsr_value)
        self.stats['min_pressure'] = min(self.stats['min_pressure'], fsr_value)
        
        total_sum = sum(self.fsr_history) + fsr_value
        self.stats['avg_pressure'] = total_sum / len(self.fsr_history) if self.fsr_history else fsr_value
        
        if pressure_category in self.stats['pressure_events']:
            self.stats['pressure_events'][pressure_category] += 1
    
    def create_data_entry(self, fsr_value, pressure_category, pressure_label):
        """Create a data entry for logging"""
        return {
            'timestamp': datetime.now().isoformat(),
            'fsr_value': fsr_value,
            'pressure_category': pressure_category,
            'pressure_label': pressure_label,
            'reading_number': self.stats['total_readings']
        }
    
    def save_to_csv(self, filename=None):

        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"fsr_session_{timestamp}.csv"
        
        with open(filename, 'w', newline='') as csvfile:
            if self.session_data:
                fieldnames = self.session_data[0].keys()
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(self.session_data)
                print(f"📊 Data saved to {filename}")
                return filename
        return None
    
    def save_to_json(self, filename=None):
        """Save session data and statistics to JSON file"""
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"fsr_session_{timestamp}.json"
        
        session_summary = {
            'session_info': {
                'start_time': self.stats['session_start'].isoformat() if self.stats['session_start'] else None,
                'end_time': datetime.now().isoformat(),
                'duration_seconds': (datetime.now() - self.stats['session_start']).total_seconds() if self.stats['session_start'] else 0,
                'arduino_port': self.port
            },
            'statistics': self.stats,
            'data': self.session_data
        }
        
        with open(filename, 'w') as jsonfile:
            json.dump(session_summary, jsonfile, indent=2)
            print(f"📋 Session summary saved to {filename}")
            return filename
        return None
    
    def print_live_stats(self):
        """Print live statistics"""
        if self.stats['total_readings'] > 0:
            print(f"\n LIVE STATS:")
            print(f"   Readings: {self.stats['total_readings']}")
            print(f"   Current: {self.fsr_history[-1] if self.fsr_history else 0}")
            print(f"   Max: {self.stats['max_pressure']}")
            print(f"   Min: {self.stats['min_pressure']}")
            print(f"   Avg: {self.stats['avg_pressure']:.1f}")
            print(f"   Events: L:{self.stats['pressure_events']['light_touch']} "
                  f"LS:{self.stats['pressure_events']['light_squeeze']} "
                  f"M:{self.stats['pressure_events']['medium_squeeze']} "
                  f"S:{self.stats['pressure_events']['strong_squeeze']}")
            print("-" * 50)
    
    def monitor_fsr(self, duration_seconds=None, log_to_file=True, show_stats_interval=10):
        """Main monitoring function with advanced features"""
        if not self.is_connected:
            print("Arduino not connected!")
            return
        
        self.is_monitoring = True
        start_time = time.time()
        last_stats_time = start_time
        
        print(" FSR monitoring started... | Commands: Ctrl+C to stop")
        print("=" * 60)
        
        try:
            while self.is_monitoring:
                # Check duration limit
                if duration_seconds and (time.time() - start_time) > duration_seconds:
                    print(f"⏰ Monitoring completed ({duration_seconds}s)")
                    break
                
                # Read Arduino data
                if self.arduino.in_waiting > 0:
                    line = self.arduino.readline().decode('utf-8').strip()
                    
                    if line.startswith("FSR Reading:"):
                        fsr_value = int(line.split(": ")[1])
                        
                        # Classify pressure
                        pressure_category, pressure_label, emoji = self.classify_pressure(fsr_value)
                        
                        # Update data structures
                        self.fsr_history.append(fsr_value)
                        self.update_statistics(fsr_value, pressure_category)
                        
                        # Create data entry
                        data_entry = self.create_data_entry(fsr_value, pressure_category, pressure_label)
                        self.session_data.append(data_entry)
                        
                        # Display reading
                        timestamp = datetime.now().strftime('%H:%M:%S')
                        print(f"[{timestamp}] {emoji} FSR: {fsr_value:4d} | {pressure_label}")
                        
                        # Special alerts
                        if fsr_value > 950:
                            print("🚨 EXTREME PRESSURE DETECTED!")
                        elif fsr_value > 800:
                            print("⚠️  High pressure warning")
                        
                        # Periodic statistics
                        if time.time() - last_stats_time > show_stats_interval:
                            self.print_live_stats()
                            last_stats_time = time.time()
                
        except KeyboardInterrupt:
            print("\n🛑 Stopping monitoring...")
        
        finally:
            self.is_monitoring = False
            
            print("\n" + "=" * 60)
            print("📊 FINAL SESSION SUMMARY")
            print("=" * 60)
            self.print_live_stats()
            
            if log_to_file and self.session_data:
                csv_file = self.save_to_csv()
                json_file = self.save_to_json()
                print(f"💾 Files saved: {csv_file}, {json_file}")
    
    def disconnect(self):
        """Disconnect from Arduino"""
        self.is_monitoring = False
        if self.arduino:
            self.arduino.close()
            self.is_connected = False
            print("🔌 Arduino disconnected")

if __name__ == "__main__":
    fsr = AdvancedFSRController(port='/dev/cu.usbmodem1101')
    
    if fsr.connect():
        try:
            fsr.monitor_fsr(log_to_file=True, show_stats_interval=15)
            
        finally:
            fsr.disconnect()
    else:
        print("Failed to connect to Arduino")
import sys
import serial.tools.list_ports
from typing import Optional, Union, List

class ArduinoNotFoundError(Exception):
    """Raised when no Arduino is found on any serial port."""
    pass

class MultipleArduinoPortsFoundError(Exception):
    """Raised when more than one Arduino is detected."""
    def __init__(self, ports: List[str]):
        super().__init__(f"Multiple Arduino ports found: {ports}")
        self.ports = ports

def find_arduino_ports() -> Union[str, List[str]]:
    """
    Scan the system's serial ports and identify Arduino devices.

    Uses USB vendor/product IDs, device descriptions, and platform-specific
    naming conventions to detect Arduino ports.

    Raises:
        ArduinoNotFoundError: if no Arduino devices are found.
        MultipleArduinoPortsFoundError: if more than one Arduino is found.
    Returns:
        - A single port name (str) if exactly one Arduino device is found.
        - A list of port names (List[str]) if multiple Arduino devices are found.
    """
    arduino_ports: List[str] = []
    ports = list(serial.tools.list_ports.comports())

    arduino_vid_pid = [
        (0x2341, 0x0043),  # Uno
        (0x2341, 0x0001),
        (0x2341, 0x0243),  # Leonardo
        (0x2341, 0x8036),  # Mega 2560
        (0x2341, 0x804d),  # Mega ADK
        (0x2341, 0x804e),  # Leonardo ETH
        (0x10C4, 0xEA60),  # CP210x UART Bridge
        (0x1A86, 0x7523),  # CH340 converter
    ]

    for port in ports:
        nm = port.device
        desc = (port.description or "").lower()
        man = (port.manufacturer or "").lower()
        vid, pid = port.vid, port.pid

        if (vid, pid) in arduino_vid_pid:
            arduino_ports.append(nm)
            continue
        if "arduino" in desc or "arduino" in man:
            arduino_ports.append(nm)
            continue

        if sys.platform.startswith("darwin") and (nm.startswith("/dev/cu.usbmodem") or nm.startswith("/dev/cu.usbserial")):
            arduino_ports.append(nm)
        elif sys.platform.startswith("linux") and (nm.startswith("/dev/ttyACM") or nm.startswith("/dev/ttyUSB")):
            arduino_ports.append(nm)
        elif sys.platform.startswith("win") and "arduino" in desc:
            arduino_ports.append(nm)

    if not arduino_ports:
        raise ArduinoNotFoundError()
    if len(arduino_ports) > 1:
        raise MultipleArduinoPortsFoundError(arduino_ports)

    return arduino_ports[0]
import sys
import threading
import time
import csv
import argparse
import re
from datetime import datetime

import serial
from code.conn.detector import (
    find_arduino_ports,
    ArduinoNotFoundError,
    MultipleArduinoPortsFoundError,
)

POLL_INTERVAL = 0.01  

class VernierFSRLogger:
    def __init__(self, baud=9600, timeout=1.0):
        try:
            p = find_arduino_ports()
        except ArduinoNotFoundError:
            sys.exit("No Arduino found. Plug it in and try again.")
        except MultipleArduinoPortsFoundError as e:
            sys.exit(f"Multiple Arduinos found: {e.ports!r}")
        self.port = p if isinstance(p, str) else p[0]
        print(f"→ Opening {self.port} @ {baud} baud")
        self.ser = serial.Serial(self.port, baudrate=baud, timeout=timeout)
        time.sleep(2)               # let Arduino reboot
        self.ser.reset_input_buffer()
        self.is_logging = False
        self._stop_reader = threading.Event()
        self._data_lines = []

    def start_logging(self):
        if not self.is_logging:
            self.ser.write(b's')
            self.is_logging = True

    def stop_logging(self):
        if self.is_logging:
            self.ser.write(b'e')
            self.is_logging = False

    def _reader_loop(self):
        while not self._stop_reader.is_set():
            line = self.ser.readline().decode('utf-8', errors='ignore').strip()
            if line:
                timestamped_line = f"[{datetime.now().strftime('%H:%M:%S')}] {line}"
                print(timestamped_line)
                self._data_lines.append(timestamped_line)
            else:
                time.sleep(POLL_INTERVAL)

    def run_for(self, duration_seconds: float, start_delay: float = 0):
        t = threading.Thread(target=self._reader_loop, daemon=True)
        t.start()

        if start_delay > 0:
            print(f"⏳ Waiting {start_delay}s before starting logging...")
            time.sleep(start_delay)

        print(f"▶ Logging started for {duration_seconds}s...")
        self.start_logging()

        try:
            time.sleep(duration_seconds)
        except KeyboardInterrupt:
            print("\n🛑 Interrupted!")
        finally:
            self.stop_logging()
            self._stop_reader.set()
            self.ser.close()
            print("⏹ Logging stopped.")

    def save_to_csv(self, filename=None):
        if not filename:
            filename = f"vernier_log_{datetime.now():%Y%m%d_%H%M%S}.csv"

        with open(filename, "w", newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["timestamped_line"])
            for line in self._data_lines:
                writer.writerow([line])

        print(f"💾 Saved log to {filename}")
        return filename
    
    def save_clean_csv(self, filename=None):
        """
        Parse self._data_lines to extract clean numeric sensor data,
        and save to a neat CSV file.
        """
        if filename is None:
            filename = f"vernier_clean_{datetime.now():%Y%m%d_%H%M%S}.csv"

        pattern = re.compile(
            r"^\s*([\d.]+), Force\(N\): ([\d.\-]+), ΔF\(N\): ([\d.\-]+), "
            r"FSR1: (\d+), FSR2: (\d+), FSR3: (\d+)"
        )

        extracted_rows = []
        for line in self._data_lines:
            if line.startswith('['):
                try:
                    line = line.split('] ', 1)[1]
                except IndexError:
                    continue

            match = pattern.match(line)
            if match:
                extracted_rows.append(match.groups())

        if not extracted_rows:
            print("⚠️ No valid sensor data found to save.")
            return None

        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Time(s)", "Force(N)", "DeltaF(N)", "FSR1", "FSR2", "FSR3"])
            writer.writerows(extracted_rows)

        print(f"💾 Saved clean CSV to: {filename}")
        return filename

def parse_args():
    parser = argparse.ArgumentParser(description="Vernier FSR Logger CLI")
    parser.add_argument(
        "--csv", action="store_true",
        help="Save session log to CSV file after completion"
    )
    parser.add_argument(
        "--delay", type=float, default=0,
        help="Seconds to wait before starting logging"
    )
    parser.add_argument(
        "--duration", type=float, default=30,
        help="Duration in seconds to log data"
    )
    parser.add_argument(
        "--baud", type=int, default=9600,
        help="Serial baud rate"
    )
    parser.add_argument(
        "--timeout", type=float, default=1.0,
        help="Serial read timeout (seconds)"
    )
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    logger = VernierFSRLogger(baud=args.baud, timeout=args.timeout)
    logger.run_for(duration_seconds=args.duration, start_delay=args.delay)
    if args.csv:
        logger.save_to_csv()
        logger.save_clean_csv()

import sys
import threading
import time
import csv
import argparse
import re
from datetime import datetime

import serial
from code.conn.detector import (
    find_arduino_ports,
    ArduinoNotFoundError,
    MultipleArduinoPortsFoundError,
)

POLL_INTERVAL = 0.01  

class VernierFSRLogger:
    def __init__(self, baud=9600, timeout=1.0):
        try:
            p = find_arduino_ports()
        except ArduinoNotFoundError:
            sys.exit("No Arduino found. Plug it in and try again.")
        except MultipleArduinoPortsFoundError as e:
            sys.exit(f"Multiple Arduinos found: {e.ports!r}")
        self.port = p if isinstance(p, str) else p[0]
        print(f"→ Opening {self.port} @ {baud} baud")
        self.ser = serial.Serial(self.port, baudrate=baud, timeout=timeout)
        time.sleep(2)               # let Arduino reboot
        self.ser.reset_input_buffer()
        self.is_logging = False
        self._stop_reader = threading.Event()
        self._data_lines = []

    def start_logging(self):
        if not self.is_logging:
            self.ser.write(b's')
            self.is_logging = True

    def stop_logging(self):
        if self.is_logging:
            self.ser.write(b'e')
            self.is_logging = False

    def _reader_loop(self):
        while not self._stop_reader.is_set():
            line = self.ser.readline().decode('utf-8', errors='ignore').strip()
            if line:
                timestamped_line = f"[{datetime.now().strftime('%H:%M:%S')}] {line}"
                print(timestamped_line)
                self._data_lines.append(timestamped_line)
            else:
                time.sleep(POLL_INTERVAL)

    def run_for(self, duration_seconds: float, start_delay: float = 0):
        t = threading.Thread(target=self._reader_loop, daemon=True)
        t.start()

        if start_delay > 0:
            print(f"⏳ Waiting {start_delay}s before starting logging...")
            time.sleep(start_delay)

        print(f"▶ Logging started for {duration_seconds}s...")
        self.start_logging()

        try:
            time.sleep(duration_seconds)
        except KeyboardInterrupt:
            print("\n🛑 Interrupted!")
        finally:
            self.stop_logging()
            self._stop_reader.set()
            self.ser.close()
            print("⏹ Logging stopped.")

    def save_to_csv(self, filename=None):
        if not filename:
            filename = f"vernier_log_{datetime.now():%Y%m%d_%H%M%S}.csv"

        with open(filename, "w", newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["timestamped_line"])
            for line in self._data_lines:
                writer.writerow([line])

        print(f"💾 Saved log to {filename}")
        return filename
    
    def save_clean_csv(self, filename=None):
        """
        Parse self._data_lines to extract clean numeric sensor data,
        and save to a neat CSV file.
        """
        if filename is None:
            filename = f"vernier_clean_{datetime.now():%Y%m%d_%H%M%S}.csv"

        pattern = re.compile(
            r"^\s*([\d.]+), Force\(N\): ([\d.\-]+), ΔF\(N\): ([\d.\-]+), "
            r"FSR1: (\d+), FSR2: (\d+), FSR3: (\d+)"
        )

        extracted_rows = []
        for line in self._data_lines:
            if line.startswith('['):
                try:
                    line = line.split('] ', 1)[1]
                except IndexError:
                    continue

            match = pattern.match(line)
            if match:
                extracted_rows.append(match.groups())

        if not extracted_rows:
            print("⚠️ No valid sensor data found to save.")
            return None

        with open(filename, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Time(s)", "Force(N)", "DeltaF(N)", "FSR1", "FSR2", "FSR3"])
            writer.writerows(extracted_rows)

        print(f"💾 Saved clean CSV to: {filename}")
        return filename

def parse_args():
    parser = argparse.ArgumentParser(description="Vernier FSR Logger CLI")
    parser.add_argument(
        "--csv", action="store_true",
        help="Save session log to CSV file after completion"
    )
    parser.add_argument(
        "--delay", type=float, default=0,
        help="Seconds to wait before starting logging"
    )
    parser.add_argument(
        "--duration", type=float, default=30,
        help="Duration in seconds to log data"
    )
    parser.add_argument(
        "--baud", type=int, default=9600,
        help="Serial baud rate"
    )
    parser.add_argument(
        "--timeout", type=float, default=1.0,
        help="Serial read timeout (seconds)"
    )
    return parser.parse_args()

if __name__ == "__main__":
    args = parse_args()
    logger = VernierFSRLogger(baud=args.baud, timeout=args.timeout)
    logger.run_for(duration_seconds=args.duration, start_delay=args.delay)
    if args.csv:
        logger.save_to_csv()
        logger.save_clean_csv()

